!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/a3c87ab5/
"	Session.vim	/^inoremap <buffer> <silent> " =AutoPairsInsert('"')$/;"	m
'	Session.vim	/^inoremap <buffer> <silent> ' =AutoPairsInsert('''')$/;"	m
(	Session.vim	/^inoremap <buffer> <silent> ( =AutoPairsInsert('(')$/;"	m
)	Session.vim	/^inoremap <buffer> <silent> ) =AutoPairsInsert(')')$/;"	m
.\x16	Session.vim	/^inoremap .  ->$/;"	m
;"	Session.vim	/^nnoremap ;" viwa"bi"lel$/;"	m
;(	Session.vim	/^nnoremap ;( viwa)bi(lel$/;"	m
;/	Session.vim	/^nnoremap ;\/ 0i\/\/$/;"	m
;d	Session.vim	/^nnoremap ;d :mksession!$/;"	m
;g	Session.vim	/^nnoremap ;g :set operatorfunc=GrepOperator$/;"	m
;g	Session.vim	/^vnoremap ;g :call GrepOperator(visualmode())$/;"	m
;h	Session.vim	/^nnoremap ;h h$/;"	m
;j	Session.vim	/^nnoremap ;j j$/;"	m
;k	Session.vim	/^nnoremap ;k k$/;"	m
;l	Session.vim	/^nnoremap ;l l$/;"	m
;m	Session.vim	/^nnoremap ;m :make$/;"	m
;q	Session.vim	/^nnoremap ;q :mksession!$/;"	m
;s	Session.vim	/^nmap ;s :w$/;"	m
;t	Session.vim	/^nnoremap ;t :mksession!$/;"	m
;u	Session.vim	/^nnoremap ;u :GundoToggle$/;"	m
;w	Session.vim	/^nnoremap ;w :mksession!$/;"	m
<BS>	Session.vim	/^inoremap <buffer> <silent> <BS> =AutoPairsDelete()$/;"	m
<C-H>	Session.vim	/^inoremap <buffer> <silent> <C-H> =AutoPairsDelete()$/;"	m
<Down>	Session.vim	/^inoremap <expr> <Down> pumvisible() ? "\\" : "\\<Down>"$/;"	m
<M-">	Session.vim	/^inoremap <buffer> <silent> <M-"> =AutoPairsMoveCharacter('"')$/;"	m
<M-'>	Session.vim	/^inoremap <buffer> <silent> <M-'> =AutoPairsMoveCharacter('''')$/;"	m
<M-(>	Session.vim	/^inoremap <buffer> <silent> <M-(> =AutoPairsMoveCharacter('(')$/;"	m
<M-)>	Session.vim	/^inoremap <buffer> <silent> <M-)> =AutoPairsMoveCharacter(')')$/;"	m
<M-[>	Session.vim	/^inoremap <buffer> <silent> <M-[> =AutoPairsMoveCharacter('[')$/;"	m
<M-]>	Session.vim	/^inoremap <buffer> <silent> <M-]> =AutoPairsMoveCharacter(']')$/;"	m
<M-b>	Session.vim	/^inoremap <buffer> <silent> <M-b> =AutoPairsBackInsert()$/;"	m
<M-e>	Session.vim	/^inoremap <buffer> <silent> <M-e> =AutoPairsFastWrap()$/;"	m
<M-n>	Session.vim	/^inoremap <buffer> <silent> <M-n> :call AutoPairsJump()$/;"	m
<M-n>	Session.vim	/^noremap <buffer> <silent> <M-n> :call AutoPairsJump()$/;"	m
<M-p>	Session.vim	/^inoremap <buffer> <silent> <expr> <M-p> AutoPairsToggle()$/;"	m
<M-p>	Session.vim	/^noremap <buffer> <silent> <M-p> :call AutoPairsToggle()$/;"	m
<M-{>	Session.vim	/^inoremap <buffer> <silent> <M-{> =AutoPairsMoveCharacter('{')$/;"	m
<M-}>	Session.vim	/^inoremap <buffer> <silent> <M-}> =AutoPairsMoveCharacter('}')$/;"	m
<Nul>	Session.vim	/^imap <Nul> <C-Space>$/;"	m
<Plug>(CommandT)	Session.vim	/^nnoremap <silent> <Plug>(CommandT) :CommandT$/;"	m
<Plug>(CommandTBuffer)	Session.vim	/^nnoremap <silent> <Plug>(CommandTBuffer) :CommandTBuffer$/;"	m
<Plug>(CommandTCommand)	Session.vim	/^nnoremap <silent> <Plug>(CommandTCommand) :CommandTCommand$/;"	m
<Plug>(CommandTHelp)	Session.vim	/^nnoremap <silent> <Plug>(CommandTHelp) :CommandTHelp$/;"	m
<Plug>(CommandTHistory)	Session.vim	/^nnoremap <silent> <Plug>(CommandTHistory) :CommandTHistory$/;"	m
<Plug>(CommandTJump)	Session.vim	/^nnoremap <silent> <Plug>(CommandTJump) :CommandTJump$/;"	m
<Plug>(CommandTLine)	Session.vim	/^nnoremap <silent> <Plug>(CommandTLine) :CommandTLine$/;"	m
<Plug>(CommandTMRU)	Session.vim	/^nnoremap <silent> <Plug>(CommandTMRU) :CommandTMRU$/;"	m
<Plug>(CommandTSearch)	Session.vim	/^nnoremap <silent> <Plug>(CommandTSearch) :CommandTSearch$/;"	m
<Plug>(CommandTTag)	Session.vim	/^nnoremap <silent> <Plug>(CommandTTag) :CommandTTag$/;"	m
<Plug>NetrwBrowseX	Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX/;"	m
<Plug>NetrwBrowseXVis	Session.vim	/^vnoremap <silent> <Plug>NetrwBrowseXVis :call netrw#BrowseXVis()$/;"	m
<S-Tab>	Session.vim	/^inoremap <expr> <S-Tab> pumvisible() ? "\\" : "\\<S-Tab>"$/;"	m
<SNR>16_AutoPairsReturn	Session.vim	/^inoremap <silent> <SNR>16_AutoPairsReturn =AutoPairsReturn()$/;"	m
<Up>	Session.vim	/^inoremap <expr> <Up> pumvisible() ? "\\" : "\\<Up>"$/;"	m
STUPID_JSON_H_	stupid_json/stupid_json.h	/^#define STUPID_JSON_H_$/;"	d
STUPID_LOCKFREE_QUEUE_H_	stupid_lockfree_queue/stupid_lockfree_queue.h	/^#define STUPID_LOCKFREE_QUEUE_H_$/;"	d
STUPID_LOGGABLE_H_	stupid_loggable/stupid_loggable.h	/^#define STUPID_LOGGABLE_H_$/;"	d
STUPID_LOGGABLE_IMPL_H_	stupid_loggable/stupid_loggable_impl.h	/^#define STUPID_LOGGABLE_IMPL_H_$/;"	d
STUPID_QUEUE_NODE_H_	stupid_lockfree_queue/stupid_queue_node.h	/^#define STUPID_QUEUE_NODE_H_$/;"	d
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
[	Session.vim	/^inoremap <buffer> <silent> [ =AutoPairsInsert('[')$/;"	m
\\b	Session.vim	/^nmap \\b <Plug>(CommandTBuffer)$/;"	m
\\d	Session.vim	/^nnoremap \\d :YcmShowDetailedDiagnostic$/;"	m
\\j	Session.vim	/^nmap \\j <Plug>(CommandTJump)$/;"	m
\\t	Session.vim	/^nmap \\t <Plug>(CommandT)$/;"	m
\x16	Session.vim	/^inoremap <buffer> <silent>   =AutoPairsSpace()$/;"	m
\x16	Session.vim	/^nnoremap   za$/;"	m
\x16\b	Session.vim	/^inoremap <buffer> <silent>  =AutoPairsDelete()$/;"	m
\x16\t	Session.vim	/^inoremap <expr> 	 pumvisible() ? "\\" : "\\	"$/;"	m
]	Session.vim	/^inoremap <buffer> <silent> ] =AutoPairsInsert(']')$/;"	m
`	Session.vim	/^inoremap <buffer> <silent> ` =AutoPairsInsert('`')$/;"	m
build_json	stupid_json/stupid_json.h	/^        void build_json(std::string& trunk) { return; }$/;"	f	namespace:stupid::stupid_json	typeref:typename:void
build_json	stupid_json/stupid_json.h	/^        void build_json(std::string& trunk, const std::string& key, const char* v)$/;"	f	namespace:stupid::stupid_json	typeref:typename:void
build_json	stupid_json/stupid_json.h	/^        void build_json(std::string& trunk, const std::string& key, const char* v, another_kvs../;"	f	namespace:stupid::stupid_json	typeref:typename:void
build_json	stupid_json/stupid_json.h	/^        void build_json(std::string& trunk, const std::string& key, const std::string& v)$/;"	f	namespace:stupid::stupid_json	typeref:typename:void
build_json	stupid_json/stupid_json.h	/^        void build_json(std::string& trunk, const std::string& key, const value& v)$/;"	f	namespace:stupid::stupid_json	typeref:typename:void
build_json	stupid_json/stupid_json.h	/^        void build_json(std::string& trunk, const std::string& key, const value& v, another_kvs./;"	f	namespace:stupid::stupid_json	typeref:typename:void
build_json	stupid_json/stupid_json.h	/^        void build_json(std::string& trunk, const std::string& key, std::string& v, another_kvs./;"	f	namespace:stupid::stupid_json	typeref:typename:void
cla\x16	Session.vim	/^inoremap cla  class $/;"	m
data	stupid_lockfree_queue/stupid_queue_node.h	/^		T data;$/;"	m	class:stupid::stupid_queue_node	typeref:typename:T
dummy	stupid_lockfree_queue/stupid_lockfree_queue.h	/^		stupid_queue_node<T> dummy;$/;"	m	class:stupid::stupid_lockfree_queue	typeref:typename:stupid_queue_node<T>
fi\x16	Session.vim	/^inoremap fi  if ()<Left>$/;"	m
for\x16	Session.vim	/^inoremap for  for ()<Left>$/;"	m
fro\x16	Session.vim	/^inoremap fro  for ()<Left>$/;"	m
gx	Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
gx	Session.vim	/^vmap gx <Plug>NetrwBrowseXVis$/;"	m
head	stupid_lockfree_queue/stupid_lockfree_queue.h	/^		stupid_queue_node<T>* head;$/;"	m	class:stupid::stupid_lockfree_queue	typeref:typename:stupid_queue_node<T> *
if\x16	Session.vim	/^inoremap if  if ()<Left>$/;"	m
il(	Session.vim	/^onoremap il( :normal! F)vi($/;"	m
il[	Session.vim	/^onoremap il[ :normal! F]vi[$/;"	m
il{	Session.vim	/^onoremap il{ :normal! f}vi{$/;"	m
impl	stupid_loggable/stupid_loggable.h	/^		stupid_loggable_impl* impl;$/;"	m	class:stupid::stupid_loggable	typeref:typename:stupid_loggable_impl *
in(	Session.vim	/^onoremap in( :normal! f(vi($/;"	m
in[	Session.vim	/^onoremap in[ :normal! f(vi[$/;"	m
in{	Session.vim	/^onoremap in{ :normal! f(vi{$/;"	m
jk	Session.vim	/^inoremap jk $/;"	m
jk	Session.vim	/^vnoremap jk $/;"	m
next	stupid_lockfree_queue/stupid_queue_node.h	/^		stupid_queue_node<T>* next = nullptr;$/;"	m	class:stupid::stupid_queue_node	typeref:typename:stupid_queue_node<T> *
s:cpo_save	Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	Session.vim	/^let s:l = 16 - ((15 * winheight(0) + 24) \/ 49)$/;"	v
s:so_save	Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
size	stupid_lockfree_queue/stupid_lockfree_queue.h	/^		std::atomic_uint size;$/;"	m	class:stupid::stupid_lockfree_queue	typeref:typename:std::atomic_uint
str\x16	Session.vim	/^inoremap str  struct $/;"	m
stupid	stupid_json/stupid_json.h	/^namespace stupid$/;"	n
stupid	stupid_lockfree_queue/stupid_lockfree_queue.h	/^namespace stupid$/;"	n
stupid	stupid_lockfree_queue/stupid_queue_node.h	/^namespace stupid$/;"	n
stupid	stupid_loggable/stupid_loggable.h	/^namespace stupid$/;"	n
stupid	stupid_loggable/stupid_loggable_impl.h	/^namespace stupid$/;"	n
stupid_json	stupid_json/stupid_json.h	/^    namespace stupid_json $/;"	n	namespace:stupid
stupid_lockfree_queue	stupid_lockfree_queue/stupid_lockfree_queue.h	/^	class stupid_lockfree_queue$/;"	c	namespace:stupid
stupid_log_debug	stupid_loggable/stupid_loggable.cpp	/^void stupid::stupid_loggable::stupid_log_debug(const char* branch_id, ...)$/;"	f	class:stupid::stupid_loggable	typeref:typename:void
stupid_log_error	stupid_loggable/stupid_loggable.cpp	/^void stupid::stupid_loggable::stupid_log_error(const char* branch_id, ...)$/;"	f	class:stupid::stupid_loggable	typeref:typename:void
stupid_log_fatal	stupid_loggable/stupid_loggable.cpp	/^void stupid::stupid_loggable::stupid_log_fatal(const char* branch_id, ...)$/;"	f	class:stupid::stupid_loggable	typeref:typename:void
stupid_log_info	stupid_loggable/stupid_loggable.cpp	/^void stupid::stupid_loggable::stupid_log_info(const char* branch_id, ...)$/;"	f	class:stupid::stupid_loggable	typeref:typename:void
stupid_log_notice	stupid_loggable/stupid_loggable.cpp	/^void stupid::stupid_loggable::stupid_log_notice(const char* branch_id, ...)$/;"	f	class:stupid::stupid_loggable	typeref:typename:void
stupid_log_warn	stupid_loggable/stupid_loggable.cpp	/^void stupid::stupid_loggable::stupid_log_warn(const char* branch_id, ...)$/;"	f	class:stupid::stupid_loggable	typeref:typename:void
stupid_loggable	stupid_loggable/stupid_loggable.cpp	/^stupid::stupid_loggable::stupid_loggable()$/;"	f	class:stupid::stupid_loggable
stupid_loggable	stupid_loggable/stupid_loggable.h	/^	class stupid_loggable$/;"	c	namespace:stupid
stupid_loggable_impl	stupid_loggable/stupid_loggable_impl.h	/^	class stupid_loggable_impl$/;"	c	namespace:stupid
stupid_queue_node	stupid_lockfree_queue/stupid_queue_node.h	/^	class stupid_queue_node $/;"	c	namespace:stupid
swi\x16	Session.vim	/^inoremap swi  switch ()<Left>$/;"	m
tail	stupid_lockfree_queue/stupid_lockfree_queue.h	/^		stupid_queue_node<T>* tail;$/;"	m	class:stupid::stupid_lockfree_queue	typeref:typename:stupid_queue_node<T> *
tem\x16	Session.vim	/^inoremap tem  template <><Left>$/;"	m
temp	stupid_lockfree_queue/stupid_lockfree_queue.h	/^			stupid_queue_node<T> temp;$/;"	m	class:stupid::stupid_lockfree_queue	typeref:typename:stupid_queue_node<T>
typ\x16	Session.vim	/^inoremap typ  typename$/;"	m
whi\x16	Session.vim	/^inoremap whi  while ()<l eft>$/;"	m
{	Session.vim	/^inoremap <buffer> <silent> { =AutoPairsInsert('{')$/;"	m
}	Session.vim	/^inoremap <buffer> <silent> } =AutoPairsInsert('}')$/;"	m
~stupid_loggable	stupid_loggable/stupid_loggable.cpp	/^stupid::stupid_loggable::~stupid_loggable()$/;"	f	class:stupid::stupid_loggable
¢	Session.vim	/^inoremap <buffer> <silent> ¢ =AutoPairsMoveCharacter('"')$/;"	m
§	Session.vim	/^inoremap <buffer> <silent> § =AutoPairsMoveCharacter('''')$/;"	m
¨	Session.vim	/^inoremap <buffer> <silent> ¨ =AutoPairsMoveCharacter('(')$/;"	m
©	Session.vim	/^inoremap <buffer> <silent> © =AutoPairsMoveCharacter(')')$/;"	m
Û	Session.vim	/^inoremap <buffer> <silent> Û =AutoPairsMoveCharacter('[')$/;"	m
Ý	Session.vim	/^inoremap <buffer> <silent> Ý =AutoPairsMoveCharacter(']')$/;"	m
â	Session.vim	/^inoremap <buffer> <silent> â =AutoPairsBackInsert()$/;"	m
å	Session.vim	/^inoremap <buffer> <silent> å =AutoPairsFastWrap()$/;"	m
î	Session.vim	/^inoremap <buffer> <silent> î :call AutoPairsJump()$/;"	m
î	Session.vim	/^noremap <buffer> <silent> î :call AutoPairsJump()$/;"	m
ð	Session.vim	/^inoremap <buffer> <silent> <expr> ð AutoPairsToggle()$/;"	m
ð	Session.vim	/^noremap <buffer> <silent> ð :call AutoPairsToggle()$/;"	m
û	Session.vim	/^inoremap <buffer> <silent> û =AutoPairsMoveCharacter('{')$/;"	m
ý	Session.vim	/^inoremap <buffer> <silent> ý =AutoPairsMoveCharacter('}')$/;"	m
